(* autogenerated from github.com/mit-pdos/goose-nfsd/barebones *)
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.mit_pdos.goose_nfsd.addr.
From Goose Require github_com.mit_pdos.goose_nfsd.buf.
From Goose Require github_com.mit_pdos.goose_nfsd.buftxn.
From Goose Require github_com.mit_pdos.goose_nfsd.common.
From Goose Require github_com.mit_pdos.goose_nfsd.inode.
From Goose Require github_com.mit_pdos.goose_nfsd.lockmap.
From Goose Require github_com.mit_pdos.goose_nfsd.super.
From Goose Require github_com.mit_pdos.goose_nfsd.txn.
From Goose Require github_com.mit_pdos.goose_nfsd.util.

(* barebones.go *)

Definition Nfsstat3: ty := uint32T.

Definition NFS3_OK : expr := #(U32 0).

Definition NFS3ERR_PERM : expr := #(U32 1).

Definition NFS3ERR_NOENT : expr := #(U32 2).

Definition NFS3ERR_IO : expr := #(U32 5).

Definition NFS3ERR_NXIO : expr := #(U32 6).

Definition NFS3ERR_ACCES : expr := #(U32 13).

Definition NFS3ERR_EXIST : expr := #(U32 17).

Definition NFS3ERR_XDEV : expr := #(U32 18).

Definition NFS3ERR_NODEV : expr := #(U32 19).

Definition NFS3ERR_NOTDIR : expr := #(U32 20).

Definition NFS3ERR_ISDIR : expr := #(U32 21).

Definition NFS3ERR_INVAL : expr := #(U32 22).

Definition NFS3ERR_FBIG : expr := #(U32 27).

Definition NFS3ERR_NOSPC : expr := #(U32 28).

Definition NFS3ERR_ROFS : expr := #(U32 30).

Definition NFS3ERR_MLINK : expr := #(U32 31).

Definition NFS3ERR_NAMETOOLONG : expr := #(U32 63).

Definition NFS3ERR_NOTEMPTY : expr := #(U32 66).

Definition NFS3ERR_DQUOT : expr := #(U32 69).

Definition NFS3ERR_STALE : expr := #(U32 70).

Definition NFS3ERR_REMOTE : expr := #(U32 71).

Definition NFS3ERR_BADHANDLE : expr := #(U32 10001).

Definition NFS3ERR_NOT_SYNC : expr := #(U32 10002).

Definition NFS3ERR_BAD_COOKIE : expr := #(U32 10003).

Definition NFS3ERR_NOTSUPP : expr := #(U32 10004).

Definition NFS3ERR_TOOSMALL : expr := #(U32 10005).

Definition NFS3ERR_SERVERFAULT : expr := #(U32 10006).

Definition NFS3ERR_BADTYPE : expr := #(U32 10007).

Definition NFS3ERR_JUKEBOX : expr := #(U32 10008).

Module BarebonesNfs.
  Definition S := struct.decl [
    "glocks" :: struct.ptrT lockmap.LockMap.S;
    "fs" :: struct.ptrT super.FsSuper.S;
    "txn" :: struct.ptrT txn.Txn.S;
    "bitmap" :: slice.T byteT
  ].
End BarebonesNfs.

Module Fh.
  Definition S := struct.decl [
    "Ino" :: uint64T;
    "Gen" :: uint64T
  ].
End Fh.

Definition BarebonesNfs__Shutdown: val :=
  rec: "BarebonesNfs__Shutdown" "nfs" :=
    txn.Txn__Shutdown (struct.loadF BarebonesNfs.S "txn" "nfs").

(* global locking *)
Definition BarebonesNfs__glockAcq: val :=
  rec: "BarebonesNfs__glockAcq" "nfs" :=
    lockmap.LockMap__Acquire (struct.loadF BarebonesNfs.S "glocks" "nfs") #0 #0.

Definition BarebonesNfs__glockRel: val :=
  rec: "BarebonesNfs__glockRel" "nfs" :=
    lockmap.LockMap__Release (struct.loadF BarebonesNfs.S "glocks" "nfs") #0 #0.

Definition BarebonesNfs__getInode: val :=
  rec: "BarebonesNfs__getInode" "nfs" "buftxn" "inum" :=
    let: "addr" := super.FsSuper__Inum2Addr (struct.loadF BarebonesNfs.S "fs" "nfs") "inum" in
    let: "buf" := buftxn.BufTxn__ReadBuf "buftxn" "addr" (common.INODESZ * #8) in
    let: "ip" := inode.Decode "buf" "inum" in
    "ip".

Definition BarebonesNfs__GetRootInode: val :=
  rec: "BarebonesNfs__GetRootInode" "nfs" :=
    let: "buftxn" := buftxn.Begin (struct.loadF BarebonesNfs.S "txn" "nfs") in
    BarebonesNfs__getInode "nfs" "buftxn" common.ROOTINUM.

Definition BarebonesNfs__getInodeByFh: val :=
  rec: "BarebonesNfs__getInodeByFh" "nfs" "buftxn" "fh" :=
    let: "ip" := BarebonesNfs__getInode "nfs" "buftxn" (struct.get Fh.S "Ino" "fh") in
    (if: struct.loadF inode.Inode.S "Gen" "ip" ≠ struct.get Fh.S "Gen" "fh"
    then (slice.nil, NFS3ERR_STALE)
    else ("ip", NFS3_OK)).

Definition BarebonesNfs__writeInode: val :=
  rec: "BarebonesNfs__writeInode" "nfs" "buftxn" "ip" :=
    let: "addr" := super.FsSuper__Inum2Addr (struct.loadF BarebonesNfs.S "fs" "nfs") (struct.loadF inode.Inode.S "Inum" "ip") in
    buftxn.BufTxn__OverWrite "buftxn" "addr" (common.INODESZ * #8) (inode.Inode__Encode "ip").

Definition BarebonesNfs__lookupName: val :=
  rec: "BarebonesNfs__lookupName" "nfs" "dip" "name" :=
    (if: ("name" = #(str"."))
    then struct.loadF inode.Inode.S "Inum" "dip"
    else
      (if: ("name" = #(str".."))
      then struct.loadF inode.Inode.S "Parent" "dip"
      else
        let: "ip" := ref (zero_val uint64T) in
        let: "i" := ref_to uint64T #0 in
        (for: (λ: <>, ![uint64T] "i" < slice.len (struct.loadF inode.Inode.S "Contents" "dip")); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
          (if: (SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i") = #0)
          then Continue
          else
            (if: (SliceGet uint64T (struct.loadF inode.Inode.S "Names" "dip") (![uint64T] "i") = to_u64 (SliceGet byteT (Data.stringToBytes "name") #0))
            then
              "ip" <-[uint64T] SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i");;
              Break
            else #()));;
          Continue);;
        ![uint64T] "ip")).

Definition BarebonesNfs__allocInode: val :=
  rec: "BarebonesNfs__allocInode" "nfs" "buftxn" "dip" :=
    let: "ip" := ref (zero_val (refT (struct.t inode.Inode.S))) in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < slice.len (struct.loadF BarebonesNfs.S "bitmap" "nfs") * #8); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      let: "byteNum" := (![uint64T] "i") `quot` #8 in
      let: "bitNum" := (![uint64T] "i") `rem` #8 in
      (if: (SliceGet byteT (struct.loadF BarebonesNfs.S "bitmap" "nfs") "byteNum" `and` #(U8 1) ≪ "bitNum") = #(U8 0)
      then
        SliceSet byteT (struct.loadF BarebonesNfs.S "bitmap" "nfs") "byteNum" (SliceGet byteT (struct.loadF BarebonesNfs.S "bitmap" "nfs") "byteNum" `or` #(U8 1) ≪ "bitNum");;
        let: "bitaddr" := addr.MkBitAddr ((![uint64T] "i") `quot` common.NBITBLOCK) ((![uint64T] "i") `rem` common.NBITBLOCK) in
        buftxn.BufTxn__OverWrite "buftxn" "bitaddr" #1 (SliceSingleton (#(U8 1) ≪ "bitNum"));;
        "ip" <-[refT (struct.t inode.Inode.S)] BarebonesNfs__getInode "nfs" "buftxn" (![uint64T] "i");;
        inode.Inode__InitInode (![refT (struct.t inode.Inode.S)] "ip") (![uint64T] "i") (struct.loadF inode.Inode.S "Inum" "dip");;
        BarebonesNfs__writeInode "nfs" "buftxn" (![refT (struct.t inode.Inode.S)] "ip");;
        Break
      else #());;
      Continue);;
    (if: (![refT (struct.t inode.Inode.S)] "ip" = #null)
    then (slice.nil, NFS3ERR_NOSPC)
    else (![refT (struct.t inode.Inode.S)] "ip", NFS3_OK)).

Definition BarebonesNfs__allocDir: val :=
  rec: "BarebonesNfs__allocDir" "nfs" "buftxn" "dip" "name" :=
    (if: (strLen "name" = #0)
    then (slice.nil, NFS3ERR_ACCES)
    else
      (if: strLen "name" > #1
      then (slice.nil, NFS3ERR_NAMETOOLONG)
      else
        let: "existing" := BarebonesNfs__lookupName "nfs" "dip" "name" in
        (if: "existing" ≠ #0
        then (slice.nil, NFS3ERR_EXIST)
        else
          let: "ip" := ref (zero_val (refT (struct.t inode.Inode.S))) in
          let: "err" := ref (zero_val Nfsstat3) in
          "err" <-[Nfsstat3] NFS3ERR_ACCES;;
          let: "i" := ref_to uint64T #0 in
          (for: (λ: <>, ![uint64T] "i" < slice.len (struct.loadF inode.Inode.S "Contents" "dip")); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
            (if: (SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i") = #0)
            then
              let: "inum" := #2 + ![uint64T] "i" in
              "ip" <-[refT (struct.t inode.Inode.S)] BarebonesNfs__getInode "nfs" "buftxn" "inum";;
              inode.Inode__InitInode (![refT (struct.t inode.Inode.S)] "ip") "inum" (struct.loadF inode.Inode.S "Inum" "dip");;
              BarebonesNfs__writeInode "nfs" "buftxn" (![refT (struct.t inode.Inode.S)] "ip");;
              SliceSet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i") (struct.loadF inode.Inode.S "Inum" (![refT (struct.t inode.Inode.S)] "ip"));;
              SliceSet uint64T (struct.loadF inode.Inode.S "Names" "dip") (![uint64T] "i") (to_u64 (SliceGet byteT (Data.stringToBytes "name") #0));;
              BarebonesNfs__writeInode "nfs" "buftxn" "dip";;
              Break
            else #());;
            Continue);;
          (![refT (struct.t inode.Inode.S)] "ip", ![Nfsstat3] "err")))).

Definition BarebonesNfs__freeRecurse: val :=
  rec: "BarebonesNfs__freeRecurse" "nfs" "buftxn" "dip" :=
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < slice.len (struct.loadF inode.Inode.S "Contents" "dip")); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      (if: (SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i") = #0)
      then Continue
      else #());;
      Continue);;
    let: "byteNum" := (struct.loadF inode.Inode.S "Inum" "dip") `quot` #8 in
    let: "bitNum" := (struct.loadF inode.Inode.S "Inum" "dip") `rem` #8 in
    SliceSet byteT (struct.loadF BarebonesNfs.S "bitmap" "nfs") "byteNum" (SliceGet byteT (struct.loadF BarebonesNfs.S "bitmap" "nfs") "byteNum" `and` ~ (#(U8 1) ≪ "bitNum"));;
    let: "bitaddr" := addr.MkBitAddr ((struct.loadF inode.Inode.S "Inum" "dip") `quot` common.NBITBLOCK) ((struct.loadF inode.Inode.S "Inum" "dip") `rem` common.NBITBLOCK) in
    buftxn.BufTxn__OverWrite "buftxn" "bitaddr" #1 (SliceSingleton (#(U8 0))).

(* barebones_init.go *)

Definition markAlloc: val :=
  rec: "markAlloc" "super" "n" "m" :=
    util.DPrintf #1 (#(str"markAlloc: [0, %d) and [%d,%d)
    ")) #();;
    (if: "n" ≥ common.NBITBLOCK || "m" ≥ common.NBITBLOCK * struct.loadF super.FsSuper.S "NBlockBitmap" "super" || "m" < "n"
    then
      Panic ("markAlloc: configuration makes no sense");;
      #()
    else #());;
    let: "blk" := NewSlice byteT disk.BlockSize in
    let: "bn" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "bn" < "n"); (λ: <>, "bn" <-[uint64T] ![uint64T] "bn" + #1) := λ: <>,
      let: "byte" := (![uint64T] "bn") `quot` #8 in
      let: "bit" := (![uint64T] "bn") `rem` #8 in
      SliceSet byteT "blk" "byte" (SliceGet byteT "blk" "byte" `or` #(U8 1) ≪ "bit");;
      Continue);;
    disk.Write (super.FsSuper__BitmapBlockStart "super") "blk";;
    let: "blk1" := ref_to (slice.T byteT) "blk" in
    let: "blkno" := "m" `quot` common.NBITBLOCK + super.FsSuper__BitmapBlockStart "super" in
    (if: "blkno" > super.FsSuper__BitmapBlockStart "super"
    then
      "blk1" <-[slice.T byteT] NewSlice byteT disk.BlockSize;;
      #()
    else #());;
    let: "bn" := ref_to uint64T ("m" `rem` common.NBITBLOCK) in
    (for: (λ: <>, ![uint64T] "bn" < common.NBITBLOCK); (λ: <>, "bn" <-[uint64T] ![uint64T] "bn" + #1) := λ: <>,
      let: "byte" := (![uint64T] "bn") `quot` #8 in
      let: "bit" := (![uint64T] "bn") `rem` #8 in
      SliceSet byteT (![slice.T byteT] "blk1") "byte" (SliceGet byteT (![slice.T byteT] "blk1") "byte" `or` #(U8 1) ≪ "bit");;
      Continue);;
    disk.Write "blkno" (![slice.T byteT] "blk1");;
    let: "blk2" := NewSlice byteT disk.BlockSize in
    SliceSet byteT "blk2" #0 (SliceGet byteT "blk2" #0 `or` #1 ≪ #0);;
    SliceSet byteT "blk2" #0 (SliceGet byteT "blk2" #0 `or` #1 ≪ #1);;
    disk.Write (super.FsSuper__BitmapInodeStart "super") "blk2".

Definition makeFs: val :=
  rec: "makeFs" "super" :=
    util.DPrintf #1 #(str"mkfs") #();;
    let: "root" := inode.MkRootInode #() in
    util.DPrintf #1 (#(str"root %v
    ")) #();;
    let: "raddr" := super.FsSuper__Inum2Addr "super" common.ROOTINUM in
    let: "rootblk" := inode.Inode__Encode "root" in
    let: "rootbuf" := buf.MkBuf "raddr" (common.INODESZ * #8) "rootblk" in
    buf.Buf__WriteDirect "rootbuf" (struct.loadF super.FsSuper.S "Disk" "super");;
    markAlloc "super" (super.FsSuper__DataStart "super") (super.FsSuper__MaxBnum "super").

Definition BarebonesNfs__readBitmap: val :=
  rec: "BarebonesNfs__readBitmap" "nfs" :=
    let: "bitmap" := ref (zero_val (slice.T byteT)) in
    let: "start" := super.FsSuper__BitmapInodeStart (struct.loadF BarebonesNfs.S "fs" "nfs") in
    let: "i" := ref_to uint64T #0 in
    (for: (λ: <>, ![uint64T] "i" < struct.loadF super.FsSuper.S "NInodeBitmap" (struct.loadF BarebonesNfs.S "fs" "nfs")); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
      let: "blk" := disk.Read ("start" + ![uint64T] "i") in
      "bitmap" <-[slice.T byteT] SliceAppendSlice byteT (![slice.T byteT] "bitmap") "blk";;
      Continue);;
    struct.storeF BarebonesNfs.S "bitmap" "nfs" (![slice.T byteT] "bitmap").

Definition MkNfs: val :=
  rec: "MkNfs" "d" :=
    struct.new BarebonesNfs.S [
      "glocks" ::= slice.nil;
      "fs" ::= super.MkFsSuper "d";
      "txn" ::= slice.nil;
      "bitmap" ::= slice.nil
    ].

Definition BarebonesNfs__InitLocks: val :=
  rec: "BarebonesNfs__InitLocks" "nfs" :=
    struct.storeF BarebonesNfs.S "glocks" "nfs" (lockmap.MkLockMap #()).

Definition BarebonesNfs__InitTxn: val :=
  rec: "BarebonesNfs__InitTxn" "nfs" :=
    struct.storeF BarebonesNfs.S "txn" "nfs" (txn.MkTxn (struct.loadF BarebonesNfs.S "fs" "nfs")).

Definition BarebonesNfs__InitFs: val :=
  rec: "BarebonesNfs__InitFs" "nfs" :=
    makeFs (struct.loadF BarebonesNfs.S "fs" "nfs");;
    BarebonesNfs__readBitmap "nfs".

Definition BarebonesNfs__Init: val :=
  rec: "BarebonesNfs__Init" "nfs" :=
    BarebonesNfs__InitLocks "nfs";;
    BarebonesNfs__InitTxn "nfs";;
    BarebonesNfs__InitFs "nfs".

(* barebones_ops.go *)

Definition BarebonesNfs__OpGetAttr: val :=
  rec: "BarebonesNfs__OpGetAttr" "nfs" "fh" :=
    let: "buftxn" := buftxn.Begin (struct.loadF BarebonesNfs.S "txn" "nfs") in
    let: ("ip", "err") := BarebonesNfs__getInodeByFh "nfs" "buftxn" "fh" in
    buftxn.BufTxn__CommitWait "buftxn" #true;;
    ("ip", "err").

Definition BarebonesNfs__OpLookup: val :=
  rec: "BarebonesNfs__OpLookup" "nfs" "dfh" "name" :=
    let: "buftxn" := buftxn.Begin (struct.loadF BarebonesNfs.S "txn" "nfs") in
    let: ("dip", "err1") := BarebonesNfs__getInodeByFh "nfs" "buftxn" "dfh" in
    (if: "err1" ≠ NFS3_OK
    then (slice.nil, slice.nil, "err1")
    else
      let: "in" := BarebonesNfs__lookupName "nfs" "dip" "name" in
      (if: ("in" = #0)
      then (slice.nil, slice.nil, NFS3ERR_NOENT)
      else
        let: "ip" := BarebonesNfs__getInode "nfs" "buftxn" "in" in
        ("dip", "ip", NFS3_OK))).

Definition BarebonesNfs__OpMkdir: val :=
  rec: "BarebonesNfs__OpMkdir" "nfs" "dfh" "name" :=
    let: "buftxn" := buftxn.Begin (struct.loadF BarebonesNfs.S "txn" "nfs") in
    BarebonesNfs__glockAcq "nfs";;
    let: ("dip", "err1") := BarebonesNfs__getInodeByFh "nfs" "buftxn" "dfh" in
    (if: "err1" ≠ NFS3_OK
    then
      BarebonesNfs__glockRel "nfs";;
      (slice.nil, "err1")
    else
      let: ("ip", "err2") := BarebonesNfs__allocDir "nfs" "buftxn" "dip" "name" in
      (if: "err2" ≠ NFS3_OK
      then
        BarebonesNfs__glockRel "nfs";;
        (slice.nil, "err2")
      else
        buftxn.BufTxn__CommitWait "buftxn" #false;;
        BarebonesNfs__glockRel "nfs";;
        ("ip", NFS3_OK))).

Definition BarebonesNfs__OpRmdir: val :=
  rec: "BarebonesNfs__OpRmdir" "nfs" "dfh" "name" :=
    (if: ("name" = #(str"."))
    then NFS3ERR_INVAL
    else
      (if: ("name" = #(str".."))
      then NFS3ERR_EXIST
      else
        let: "buftxn" := buftxn.Begin (struct.loadF BarebonesNfs.S "txn" "nfs") in
        BarebonesNfs__glockAcq "nfs";;
        let: ("dip", "err1") := BarebonesNfs__getInodeByFh "nfs" "buftxn" "dfh" in
        (if: "err1" ≠ NFS3_OK
        then
          BarebonesNfs__glockRel "nfs";;
          "err1"
        else
          let: "in" := BarebonesNfs__lookupName "nfs" "dip" "name" in
          (if: ("in" = #0)
          then
            BarebonesNfs__glockRel "nfs";;
            NFS3ERR_NOENT
          else
            let: "i" := ref_to uint64T #0 in
            (for: (λ: <>, ![uint64T] "i" < slice.len (struct.loadF inode.Inode.S "Contents" "dip")); (λ: <>, "i" <-[uint64T] ![uint64T] "i" + #1) := λ: <>,
              (if: (SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i") = "in")
              then
                SliceSet uint64T (struct.loadF inode.Inode.S "Contents" "dip") (![uint64T] "i") #0;;
                Break
              else #());;
              Continue);;
            BarebonesNfs__writeInode "nfs" "buftxn" "dip";;
            buftxn.BufTxn__CommitWait "buftxn" #true;;
            BarebonesNfs__glockRel "nfs";;
            NFS3_OK)))).

Module Entry3.
  Definition S := struct.decl [
    "Inode" :: struct.ptrT inode.Inode.S;
    "Name" :: slice.T byteT;
    "Cookie" :: uint64T
  ].
End Entry3.

Definition makeEntry3: val :=
  rec: "makeEntry3" "ip" "name" "cookie" :=
    struct.mk Entry3.S [
      "Inode" ::= "ip";
      "Name" ::= "name";
      "Cookie" ::= "cookie"
    ].

Definition BarebonesNfs__OpReadDirPlus: val :=
  rec: "BarebonesNfs__OpReadDirPlus" "nfs" "dfh" :=
    let: "buftxn" := buftxn.Begin (struct.loadF BarebonesNfs.S "txn" "nfs") in
    let: ("dip", "err") := BarebonesNfs__getInodeByFh "nfs" "buftxn" "dfh" in
    (if: "err" ≠ NFS3_OK
    then (slice.nil, slice.nil, "err")
    else
      let: "entries" := ref (zero_val (slice.T (struct.t Entry3.S))) in
      "entries" <-[slice.T (struct.t Entry3.S)] SliceAppend (struct.t Entry3.S) (![slice.T (struct.t Entry3.S)] "entries") (makeEntry3 "dip" (Data.stringToBytes #(str".")) #1);;
      (if: struct.loadF inode.Inode.S "Parent" "dip" ≠ #0
      then
        let: "pip" := BarebonesNfs__getInode "nfs" "buftxn" (struct.loadF inode.Inode.S "Parent" "dip") in
        "entries" <-[slice.T (struct.t Entry3.S)] SliceAppend (struct.t Entry3.S) (![slice.T (struct.t Entry3.S)] "entries") (makeEntry3 "pip" (Data.stringToBytes #(str"..")) #2);;
        #()
      else #());;
      let: "ir" := ref_to uint64T #0 in
      (for: (λ: <>, ![uint64T] "ir" < slice.len (struct.loadF inode.Inode.S "Contents" "dip")); (λ: <>, "ir" <-[uint64T] ![uint64T] "ir" + #1) := λ: <>,
        let: "i" := slice.len (struct.loadF inode.Inode.S "Contents" "dip") - ![uint64T] "ir" - #1 in
        (if: (SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") "i" = #0)
        then Continue
        else
          let: "ip" := BarebonesNfs__getInode "nfs" "buftxn" (SliceGet uint64T (struct.loadF inode.Inode.S "Contents" "dip") "i") in
          "entries" <-[slice.T (struct.t Entry3.S)] SliceAppend (struct.t Entry3.S) (![slice.T (struct.t Entry3.S)] "entries") (makeEntry3 "ip" (SliceSingleton (SliceGet uint64T (struct.loadF inode.Inode.S "Names" "dip") "i")) ("i" + #3)));;
        Continue);;
      ("dip", ![slice.T (struct.t Entry3.S)] "entries", NFS3_OK)).
