(* autogenerated from alloc *)
Require Import Perennial.goose_lang.prelude.
From Perennial.goose_lang Require Import prelude.
From Perennial.goose_lang Require Import ffi.disk_prelude.

From Goose Require github_com.mit_pdos.goose_nfsd.util.

(* Allocator uses a bit map to allocate and free numbers. Bit 0
   corresponds to number 0, bit 1 to 1, and so on. *)
Module Alloc.
  Definition S := struct.decl [
    "mu" :: lockRefT;
    "next" :: uint64T;
    "bitmap" :: slice.T byteT
  ].
End Alloc.

Definition MkAlloc: val :=
  rec: "MkAlloc" "bitmap" :=
    let: "a" := struct.new Alloc.S [
      "mu" ::= lock.new #();
      "next" ::= #0;
      "bitmap" ::= "bitmap"
    ] in
    "a".

Definition Alloc__incNext: val :=
  rec: "Alloc__incNext" "a" :=
    struct.storeF Alloc.S "next" "a" (struct.loadF Alloc.S "next" "a" + #1);;
    (if: struct.loadF Alloc.S "next" "a" ≥ slice.len (struct.loadF Alloc.S "bitmap" "a") * #8
    then
      struct.storeF Alloc.S "next" "a" #0;;
      #()
    else #());;
    struct.loadF Alloc.S "next" "a".

(* Returns a free number in the bitmap *)
Definition Alloc__allocBit: val :=
  rec: "Alloc__allocBit" "a" :=
    let: "num" := ref (zero_val uint64T) in
    lock.acquire (struct.loadF Alloc.S "mu" "a");;
    "num" <-[uint64T] Alloc__incNext "a";;
    let: "start" := ![uint64T] "num" in
    Skip;;
    (for: (λ: <>, #true); (λ: <>, Skip) := λ: <>,
      let: "bit" := (![uint64T] "num") `rem` #8 in
      let: "byte" := (![uint64T] "num") `quot` #8 in
      util.DPrintf #10 (#(str"allocBit: s %d num %d
      ")) "start" (![uint64T] "num");;
      (if: (SliceGet byteT (struct.loadF Alloc.S "bitmap" "a") "byte" & #(U8 1) ≪ "bit") = #(U8 0)
      then
        SliceSet byteT (struct.loadF Alloc.S "bitmap" "a") "byte" (SliceGet byteT (struct.loadF Alloc.S "bitmap" "a") "byte" ∥ #(U8 1) ≪ "bit");;
        Break
      else
        "num" <-[uint64T] Alloc__incNext "a";;
        (if: (![uint64T] "num" = "start")
        then
          "num" <-[uint64T] #0;;
          Break
        else Continue)));;
    lock.release (struct.loadF Alloc.S "mu" "a");;
    ![uint64T] "num".

Definition Alloc__freeBit: val :=
  rec: "Alloc__freeBit" "a" "bn" :=
    lock.acquire (struct.loadF Alloc.S "mu" "a");;
    let: "byte" := "bn" `quot` #8 in
    let: "bit" := "bn" `rem` #8 in
    SliceSet byteT (struct.loadF Alloc.S "bitmap" "a") "byte" (SliceGet byteT (struct.loadF Alloc.S "bitmap" "a") "byte" & ~ (#(U8 1) ≪ "bit"));;
    lock.release (struct.loadF Alloc.S "mu" "a").

Definition Alloc__AllocNum: val :=
  rec: "Alloc__AllocNum" "a" :=
    let: "num" := Alloc__allocBit "a" in
    "num".

Definition Alloc__FreeNum: val :=
  rec: "Alloc__FreeNum" "a" "num" :=
    (if: ("num" = #0)
    then
      Panic "FreeNum";;
      #()
    else #());;
    Alloc__freeBit "a" "num".


(* This is the end of the autogenerated code; now begins the proof.
   I'm having import problems in the alloc_proof file so I'm working here for now... *)


From Perennial.goose_lang.lib Require Import encoding.
From Perennial.program_proof Require Import proof_prelude.
From Perennial.program_proof Require Import disk_lib.
From Perennial.program_proof Require Import marshal_proof.

Section proof.
Context `{!heapG Σ}.

Local Opaque struct_mapsto load_ty store_ty.

(* Let's define what a valid allocator even looks like. *)

Definition alloc_fields (l:loc) (next:u64) (bitmap:Slice.t): iProp Σ :=
  l ↦[Alloc.S :: "next"] #next ∗
  l ↦[Alloc.S :: "bitmap"] slice_val bitmap. (* casts Slice.t to a val (see slice.v) *)

(* First stab at a lemma - it's incorrect until further notice. *)
(* How do I do addition on a u64? *)

(* increment x mod n *)
Definition mod_inc (x n: u64) : u64 :=
  if (ge_dec (int.nat x + 1) (int.nat n)) then 0 else u64_instance.u64.(@word.add 64) x 1.

Theorem incNext_spec stk E l next bitmap :
  {{{ alloc_fields l next bitmap }}}
    Alloc__incNext #l @stk; E
  {{{ RET #(mod_inc next (8*int.nat bitmap.(Slice.sz)));
        alloc_fields l (mod_inc next (8*int.nat bitmap.(Slice.sz))) bitmap }}}.

Proof.
  iIntros (Φ) "Halloc HΦ".
  wp_call.
  unfold alloc_fields in *.
  iDestruct "Halloc" as "[H1 H2]".
  wp_loadField. (* needed to split Halloc to make this work *)
  wp_storeField.
  wp_loadField.

  wp_rec. (* this actually did something tiny *)

  wp_loadField. (* why does this work now? *)

  wp_pures.

  destruct (bool_decide (* destruct on the underlying boolean; kinda gross rn tho *)
            (int.val (u64_instance.u64.(@word.mul 64) bitmap.(Slice.sz) 8)
             ≤ int.val (u64_instance.u64.(@word.add 64) next 1))) eqn:Hinc.
  
  (* this may be easier if we define mod_inc to fit the structure better. *)
  - wp_if. wp_storeField. wp_seq. wp_loadField. unfold mod_inc in *.
    destruct (ge_dec (int.nat next + 1) (int.nat (8 * int.nat bitmap.(Slice.sz)))) eqn:Hinc2.
    + iApply "HΦ". iFrame.
    + admit. (* contradiction here *)
  - wp_if. wp_seq. wp_loadField. unfold mod_inc in *.
    destruct (ge_dec (int.nat next + 1) (int.nat (8 * int.nat bitmap.(Slice.sz)))) eqn:Hinc2.
    + admit. (* contradiction here *)
    + iApply "HΦ". iFrame.
Admitted.










